package transaction

import (
	"testing"

	"github.com/qqvv/go-nyzo/crypto"
)

func GetValidTestKey() crypto.PrivateKey {
	return crypto.PrivateKey([64]byte{
		0x51, 0x58, 0x50, 0x1b, 0xdf, 0xec, 0x36, 0xc8,
		0xce, 0xd9, 0x39, 0x63, 0x9b, 0xfd, 0xd8, 0x89,
		0x3c, 0xff, 0x77, 0x3c, 0x76, 0x70, 0x3d, 0xf6,
		0xf3, 0x62, 0xda, 0xa0, 0xb9, 0xab, 0x1f, 0x83,
		0x3e, 0xf9, 0x3e, 0x8c, 0xc7, 0x4e, 0xa9, 0xc1,
		0x9a, 0x80, 0xbd, 0xc3, 0xec, 0xee, 0xd0, 0x1c,
		0x24, 0xfd, 0x35, 0x22, 0xf9, 0xf2, 0x7f, 0x60,
		0x5e, 0x04, 0x18, 0x8e, 0xdc, 0x76, 0xae, 0x98,
	})
}

func GetInvalidTestKey() crypto.PrivateKey {
	return crypto.PrivateKey([64]byte{
		0x69, 0xff, 0xff, 0xd3, 0x6a, 0xac, 0xf7, 0x51,
		0xbc, 0x7e, 0xf2, 0x5e, 0x7b, 0x53, 0x51, 0xd7,
		0x41, 0x38, 0x78, 0x68, 0xbc, 0x02, 0x1b, 0x40,
		0x56, 0xc3, 0x36, 0xeb, 0xbc, 0xaf, 0x68, 0x6e,
		0xc6, 0x50, 0x57, 0x1d, 0xb9, 0x19, 0xec, 0x7d,
		0x45, 0x15, 0xc4, 0x3e, 0x85, 0x41, 0xe0, 0xc3,
		0xc8, 0x3d, 0x1f, 0x1a, 0xca, 0x11, 0x5e, 0xdf,
		0x43, 0x72, 0xca, 0x62, 0x46, 0x57, 0xab, 0x01,
	})
}

func TestTxSerialization(t *testing.T) {
	tests := []struct {
		bytes []byte
		valid bool
	}{
		{
			bytes: []byte{},
			valid: false,
		},
		{
			// Missing byte from signature
			bytes: []byte{
				0x02,                                           // Type
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Timestamp
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Amount
				0x82, 0x47, 0xaa, 0x69, 0x29, 0x53, 0x6b, 0x29,
				0x14, 0x96, 0x9c, 0xde, 0x3a, 0x28, 0xb1, 0x72,
				0xa4, 0x51, 0xc8, 0x71, 0xd0, 0xae, 0x9c, 0xcd,
				0x47, 0x95, 0x7f, 0x33, 0x93, 0x37, 0x50, 0x65, // RecipientID
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PrevHashHeight
				0x3e, 0xf9, 0x3e, 0x8c, 0xc7, 0x4e, 0xa9, 0xc1,
				0x9a, 0x80, 0xbd, 0xc3, 0xec, 0xee, 0xd0, 0x1c,
				0x24, 0xfd, 0x35, 0x22, 0xf9, 0xf2, 0x7f, 0x60,
				0x5e, 0x04, 0x18, 0x8e, 0xdc, 0x76, 0xae, 0x98, // SenderID
				0x20, // SenderData length
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // SenderData
				0xa3, 0x7a, 0xca, 0x30, 0x26, 0xd7, 0x4a, 0xfc,
				0x5a, 0x1d, 0xfa, 0x94, 0x25, 0x62, 0xcd, 0x5b,
				0xf7, 0x5b, 0x0e, 0x8d, 0xdd, 0x8a, 0xe5, 0x97,
				0x15, 0xd5, 0x64, 0x56, 0xf6, 0x3a, 0x2b, 0xa4,
				0xf4, 0xc7, 0xda, 0xd2, 0x7d, 0x74, 0x7d, 0x1c,
				0x1f, 0x3b, 0x7a, 0x06, 0x3d, 0xf1, 0xf3, 0x0b,
				0xed, 0xf8, 0xbc, 0x6d, 0x78, 0x4a, 0x22, 0x25,
				0xe0, 0x34, 0xfb, 0xe1, 0xdb, 0x21, 0xa7, // SenderSig
			},
			valid: false,
		},
		{
			// Wrong SenderData length
			bytes: []byte{
				0x02,                                           // Type
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Timestamp
				0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Amount
				0x82, 0x47, 0xaa, 0x69, 0x29, 0x53, 0x6b, 0x29,
				0x14, 0x96, 0x9c, 0xde, 0x3a, 0x28, 0xb1, 0x72,
				0xa4, 0x51, 0xc8, 0x71, 0xd0, 0xae, 0x9c, 0xcd,
				0x47, 0x95, 0x7f, 0x33, 0x93, 0x37, 0x50, 0x65, // RecipientID
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // PrevHashHeight
				0x3e, 0xf9, 0x3e, 0x8c, 0xc7, 0x4e, 0xa9, 0xc1,
				0x9a, 0x80, 0xbd, 0xc3, 0xec, 0xee, 0xd0, 0x1c,
				0x24, 0xfd, 0x35, 0x22, 0xf9, 0xf2, 0x7f, 0x60,
				0x5e, 0x04, 0x18, 0x8e, 0xdc, 0x76, 0xae, 0x98, // SenderID
				0xFF, // SenderData length
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
				0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // SenderData
				0xa3, 0x7a, 0xca, 0x30, 0x26, 0xd7, 0x4a, 0xfc,
				0x5a, 0x1d, 0xfa, 0x94, 0x25, 0x62, 0xcd, 0x5b,
				0xf7, 0x5b, 0x0e, 0x8d, 0xdd, 0x8a, 0xe5, 0x97,
				0x15, 0xd5, 0x64, 0x56, 0xf6, 0x3a, 0x2b, 0xa4,
				0xf4, 0xc7, 0xda, 0xd2, 0x7d, 0x74, 0x7d, 0x1c,
				0x1f, 0x3b, 0x7a, 0x06, 0x3d, 0xf1, 0xf3, 0x0b,
				0xed, 0xf8, 0xbc, 0x6d, 0x78, 0x4a, 0x22, 0x25,
				0xe0, 0x34, 0xfb, 0xe1, 0xdb, 0x21, 0xa7, 0x09, // SenderSig
			},
			valid: true,
		},
	}

	for i, test := range tests {
		tx := &Tx{}

		err := tx.Deserialize(test.bytes)
		if test.valid && err != nil {
			t.Errorf("Tx deserialization failed (%v): %v", i, err)
		}

		valid, err := tx.Validate()
		if !test.valid && valid {
			t.Errorf("expected Tx deserialization to fail (%v)", i)
		}
		if test.valid && !valid {
			t.Errorf("Tx validation failed (%v): %v", i, err)
		}
	}
}

func TestTxValidate(t *testing.T) {
	tests := []struct {
		tx    *Tx
		key   crypto.PrivateKey
		valid bool
	}{
		{
			// Coingeneration type
			tx: &Tx{
				Type:   byte(0),
				Amount: 1,
			},
			key:   GetValidTestKey(),
			valid: false,
		},
		{
			// Amount less than minimum of 1 unit
			tx: &Tx{
				Type:   byte(2),
				Amount: 0,
			},
			key:   GetValidTestKey(),
			valid: false,
		},
		{
			// SenderID does not match RecipientID (seed)
			tx: &Tx{
				Type:   byte(1),
				Amount: 1,
				RecipientID: crypto.PublicKey([32]byte{
					0xc6, 0x50, 0x57, 0x1d, 0xb9, 0x19, 0xec, 0x7d,
					0x45, 0x15, 0xc4, 0x3e, 0x85, 0x41, 0xe0, 0xc3,
					0xc8, 0x3d, 0x1f, 0x1a, 0xca, 0x11, 0x5e, 0xdf,
					0x43, 0x72, 0xca, 0x62, 0x46, 0x57, 0xab, 0x01,
				}),
			},
			key:   GetValidTestKey(),
			valid: false,
		},
		{
			tx: &Tx{
				Type:   byte(2),
				Amount: 1,
				RecipientID: crypto.PublicKey([32]byte{
					0xc6, 0x50, 0x57, 0x1d, 0xb9, 0x19, 0xec, 0x7d,
					0x45, 0x15, 0xc4, 0x3e, 0x85, 0x41, 0xe0, 0xc3,
					0xc8, 0x3d, 0x1f, 0x1a, 0xca, 0x11, 0x5e, 0xdf,
					0x43, 0x72, 0xca, 0x62, 0x46, 0x57, 0xab, 0x01,
				}),
			},
			key:   GetValidTestKey(),
			valid: true,
		},
		{
			// SenderID matches RecipientID (standard)
			tx: &Tx{
				Type:        byte(2),
				Amount:      1,
				RecipientID: GetValidTestKey().PubKey(),
			},
			key:   GetValidTestKey(),
			valid: false,
		},
		{
			// Invalid key
			tx: &Tx{
				Type:   byte(2),
				Amount: 1,
				RecipientID: crypto.PublicKey([32]byte{
					0xc6, 0x50, 0x57, 0x1d, 0xb9, 0x19, 0xec, 0x7d,
					0x45, 0x15, 0xc4, 0x3e, 0x85, 0x41, 0xe0, 0xc3,
					0xc8, 0x3d, 0x1f, 0x1a, 0xca, 0x11, 0x5e, 0xdf,
					0x43, 0x72, 0xca, 0x62, 0x46, 0x57, 0xab, 0x01,
				}),
			},
			key:   GetInvalidTestKey(),
			valid: false,
		},
	}

	for i, test := range tests {
		test.tx.Sign(test.key)
		valid, err := test.tx.Validate()
		if !valid && test.valid {
			t.Errorf("expected Tx to be valid (%v): %v", i, err)
		}
		if valid && !test.valid {
			t.Errorf("expected Tx to be invalid (%v)", i)
		}
	}
}
